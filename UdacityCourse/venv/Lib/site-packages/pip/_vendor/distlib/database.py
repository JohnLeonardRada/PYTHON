<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 13. Transactions et Accès concurrents</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="readonly.html" title="Chapitre 12. Read-only entities"/><link rel="next" href="events.html" title="Chapitre 14. Intercepteurs et événements"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="readonly.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="events.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>Chapitre 13. Transactions et Accès concurrents</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="transactions.html#transactions-basics">13.1. Portées des sessions et des transactions</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-basics-uow">13.1.1. Unité de travail</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-apptx">13.1.2. Longue conversation</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-identity">13.1.3. L'identité des objets</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-basics-issues">13.1.4. Problèmes communs</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-demarcation">13.2. Démarcation des transactions de base de données</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-demarcation-nonmanaged">13.2.1. Environnement non gérés</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-jta">13.2.2. Utilisation de JTA</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-exceptions">13.2.3. Gestion des exceptions</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-demarcation-timeout">13.2.4. Timeout de transaction</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-optimistic">13.3. Contrôle de concurrence optimiste</a></span></dt><dd><dl><dt><span class="section"><a href="transactions.html#transactions-optimistic-manual">13.3.1. Vérification du versionnage au niveau applicatif</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-longsession">13.3.2. Les sessions longues et le versionnage automatique.</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-detached">13.3.3. Les objets détachés et le versionnage automatique</a></span></dt><dt><span class="section"><a href="transactions.html#transactions-optimistic-customizing">13.3.4. Personnaliser le versionnage automatique</a></span></dt></dl></dd><dt><span class="section"><a href="transactions.html#transactions-locking">13.4. Verrouillage pessimiste </a></span></dt><dt><span class="section"><a href="transactions.html#transactions-connection-release">13.5. Modes de libération de connexion</a></span></dt></dl></div><p>L'un des principaux avantages du mécanisme de contrôle des accès concurrents de Hibernate est qu'il est très facile à comprendre. Hibernate utilise directement les connexions JDBC ainsi que les ressources JTA sans y ajouter davantage de mécanisme de blocage. Nous vous recommandons de vous familiariser avec les spécifications JDBC, ANSI et d'isolement de transaction du système de gestion de la base de données que vous utilisez.  </p><p>Hibernate ne verrouille pas vos objets en mémoire. Votre application peut suivre le comportement défini par le niveau d'isolation de vos transactions de base de données. Notez que grâce à la <code class="literal">Session</code>, qui est aussi un cache de portée de transaction, Hibernate fournit des lectures répétées pour les recherches par identifiants et les requêtes d'entités (ne rapporte pas les requêtes qui retournent des valeurs scalaires).  </p><p>En plus du versioning, pour le contrôle automatique optimiste de concurrence, Hibernate fournit également une API (mineure) pour le verrouillage pessimiste des lignes, en générant une syntaxe <code class="literal">SELECT FOR UPDATE</code>. Le contrôle de concurrence optimiste et cette API seront approfondis ultérieurement dans ce chapitre.  </p><p>Nous abordons la gestion des accès concurrents en discutant de la granularité des objets <code class="literal">Configuration</code>, <code class="literal">SessionFactory</code>, et <code class="literal">Session</code>, ainsi que des transactions de la base de données et des longues transactions applicatives.  </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>13.1. Portées des sessions et des transactions</h2></div></div></div><p>Il est important de savoir qu'un objet <code class="literal">SessionFactory</code> est un objet complexe et optimisé pour fonctionner avec les threads(thread- safe). Il est coûteux à créer et est ainsi prévu pour n'être instancié qu'une seule fois via une instance <code class="literal">Configuration</code> en général au démarrage de l'application.  </p><p>Une <code class="literal">Session</code> n'est pas coûteuse, et c'est un objet non-threadsafe qui ne devrait être utilisé qu'une seule fois pour une requête unique, une conversation, une unité de travail unique et devrait être relâché ensuite. Un objet <code class="literal">Session</code> ne tentera pas d'obtenir une <code class="literal">Connection</code>JBDC (ou une <code class="literal">Datasource</code>) si ce n'est pas nécessaire, par conséquent il ne consommera pas de ressource jusqu'à son utilisation. </p><p>Afin de compléter ce tableau, vous devez également penser aux transactions de base de données. Une transaction de base de données doit être aussi courte que possible afin de réduire les risques de contention de verrou dans la base de données. De longues transactions à la base de données nuiront à l'extensibilité de vos applications lorsque confrontées à de hauts niveaux de charge. Par conséquent, ce n'est un bon design que de maintenir une transaction ouverte pendant la durée de reflexion de l'utilisateur, jusqu'à ce que l'unité de travail soit achevée.  </p><p>Quelle est la portée d'une unité de travail? Est-ce qu'une <code class="literal">Session</code> unique de Hibernate peut avoir une durée de vie dépassant plusieurs transactions à la base de données, ou bien est-ce une relation un-à-un des portées? Quand faut-il ouvrir et fermer une <code class="literal">Session</code> et comment définir les démarcations de vos transactions à la base de données ?  </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>13.1.1. Unité de travail</h3></div></div></div><p>First, let's define a unit of work. A unit of work is a design pattern described by Martin Fowler as « <span class="quote"> [maintaining] a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems. </span> »[<a class="citation" href="bi01.html#biblio-PoEAA"><span class="citation">PoEAA</span></a>] In other words, its a series of operations we wish to carry out against the database together. Basically, it is a transaction, though fulfilling a unit of work will often span multiple physical database transactions (see <a class="xref" href="transactions.html#transactions-basics-apptx" title="13.1.2. Longue conversation">Section 13.1.2, « Longue conversation »</a>). So really we are talking about a more abstract notion of a transaction. The term "business transaction" is also sometimes used in lieu of unit of work. </p><p>Tout d'abord n'utilisez pas l'anti-pattern <span class="emphasis"><em>session-par-operation</em></span> et n'ouvrez et ne fermez pas la <code class="literal">Session</code> à chacun de vos accès simples à la base de données dans un même thread ! Par conséquent, le même raisonnement est applicable à la gestion des transactions dans la base de données. Dans une application, les appels à la base de données doivent être effectués selon une séquence ordonnée et sont regroupés en unités de travail atomiques. (Notez que l'utilisation d'une connexion auto-commit après chaque déclaration SQL est inutile dans une application. Ce mode de fonctionnement existe pour les applications émettant des commandes SQL ad-hoc à partir d'une console. Hibernate désengage le mode auto-commit et s'attend à ce qu'un serveur d'applications le fasse également.) Les transactions avec la base de données ne sont jamais optionnelles. Toute communication avec une base de données doit se dérouler dans une transaction, peu importe si vous lisez ou écrivez des données. Comme déjà mentionné, le comportement auto-commit pour lire les données devrait être évité, puisque plusieurs petites transactions ne seront jamais aussi efficaces qu'une seule plus grosse clairement définie comme unité de travail. Ce dernier choix est de plus beaucoup plus facile à maintenir et plus extensible. </p><p>Le modèle d'utilisation le plus fréquemment rencontré dans des applications clients serveur multi-usagers est la <span class="emphasis"><em>session-par-requête</em></span>. Dans ce modèle, la requête d'un client est envoyée au serveur (où la couche de persistance est implémentée via Hibernate), une nouvelle <code class="literal">Session</code> Hibernate est ouverte et toutes les opérations d'accès à la base de données sont exécutées à l'intérieur de celle-ci. Lorsque le travail est terminé (et que les réponses à envoyer au client ont été préparées), la session est flushée et fermée. Une seule transaction à la base de données peut être utilisée pour répondre à la requête du client. La transaction est démarrée et validée au même moment où la Session est ouverte et fermée. La relation entre la <code class="literal">Session</code> et la <code class="literal">Transaction</code> est donc un-à-un. Cette relation entre les deux est un-à-un et ce modèle permet de répondre parfaitement aux attentes de la grande majorité des applications.  </p><p>Le défi réside dans l'implémentation. Hibernate fournit une fonction de gestion intégrée de la "session courante" pour simplifier ce pattern. Il vous suffit de démarrer une transaction lorsqu'une requête est traitée par le serveur, et la terminer avant que la réponse ne soit envoyée au client. Vous pouvez choisir la manière de l'effectuer, les solutions communes sont un <code class="literal">ServletFilter</code>, l'interception via AOP avec une coupe transverse (pointcut) sur les méthodes de type "service", ou un conteneur avec interception/proxy. Un conteneur EJB est un moyen standard d'implémenter ce genre d'acpect transverse comme la démarcation des transactions sur les EJB  session, de manière déclarative avec CMT. Si vous décidez d'utiliser la démarcation programmatique des transactions, préferrez l'API Hibernate <code class="literal">Transaction</code> traitée plus tard dans ce chapitre, afin de faciliter l'utilisation et la portabilité du code.  </p><p>Your application code can access a "current session" to process the request by calling <code class="literal">sessionFactory.getCurrentSession()</code>. You will always get a <code class="literal">Session</code> scoped to the current database transaction. This has to be configured for either resource-local or JTA environments, see <a class="xref" href="architecture.html#architecture-current-session" title="2.3. Sessions contextuelles">Section 2.3, « Sessions contextuelles  »</a>. </p><p>Il est parfois utile d'étendre la portée d'une <code class="literal">Session</code> et d'une transaction à la base de données jusqu'à ce que "la vue soit rendue". Ceci est particulièrement utile dans des applications à base de servlet qui utilisent une phase de rendue séparée une fois que la réponse a été préparée. Étendre la transaction avec la base de données jusqu'à la fin du rendering de la vue est aisé si vous implémentez votre propre intercepteur. Cependant, ce n'est pas facile si vous vous appuyez sur les EJB avec CMT, puisqu'une transaction sera achevée au retour de la méthode EJB, avant le rendu de la vue. Rendez vous sur le site Hibernate et sur le forum pour des astuces et des exemples sur le pattern <span class="emphasis"><em>Open Session in View</em></span> .  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>13.1.2. Longue conversation</h3></div></div></div><p>Le paradigme "session-per-request" n'est pas le seul élément à utiliser dans le design de vos unités de travail. Plusieurs processus d'affaire requièrent toute une série d'interactions avec l'utilisateur, entrelacées d'accès à la base de donnée. Dans une application Web ou une application d'entreprise, il serait inacceptable que la durée de vie d'une transaction s'étale sur plusieurs interactions avec l'usager. Considérez l'exemple suivant : </p><div class="itemizedlist"><ul><li><p>Un écran s'affiche. Les données vues par l'usager ont été chargées dans l'instance d'un objet <code class="literal">Session</code> , dans le cadre d'une transaction de base de données. L'usager est libre de modifier ces objets.  </p></li><li><p>L'usager clique "Sauvegarder" après 5 minutes et souhaite persister les modifications qu'il a apportées. Il s'attend à être la seule personne a avoir modifié ces données et qu'aucune modification conflictuelle ne se soit produite durant ce laps de temps.  </p></li></ul></div><p>Ceci s'appelle une unité de travail. Du point de vue de l'utilisateur: une <span class="emphasis"><em>conversation</em></span> (ou <span class="emphasis"><em>transaction d'application</em></span>). Il y a plusieurs façon de mettre ceci en place dans votre application.  </p><p>Une première implémentation naïve pourrait consister à garder la <code class="literal">Session</code> et la transaction à la base de données ouvertes durant le temps de travail de l'usager, à maintenir les enregistrements verrouillés dans la base de données afin d'éviter des modifications concurrentes et de maintenir l'isolation et l'atomicité de la transaction de l'usager. Ceci est un anti-pattern à éviter, puisque le verrouillage des enregistrements dans la base de données ne permettrait pas à l'application de gérer un grand nombre d'usagers concurrents.  </p><p>Il apparaît donc évident qu'il faille utiliser plusieurs transactions BDD afin d'implémenter la conversation. Dans ce cas, maintenir l'isolation des processus d'affaire devient partiellement la responsabilité de la couche applicative. Ainsi, la durée de vie d'une conversation devrait englober celle d'une ou de plusieurs transactions de base de données. Celle-ci sera atomique seulement si l'écriture des données mises à jour est faite exclusivement par la dernière transaction BDD la composant. Toutes les autres sous transactions BD ne doivent faire que la lecture de données. Ceci est relativement facile à mettre en place, surtout avec l'utilisation de certaines fonctionnalités d'Hibernate : </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Versionnage Automatique</em></span> - Hibernate peut gérer automatiquement les accès concurrents de manière optimiste et détecter si une modification concurrente s'est produite durant le temps de réflexion d'un usager. A vérifier en fin de conversation. </p></li><li><p><span class="emphasis"><em>Objets Détachés</em></span> - Si vous décidez d'utiliser le paradigme <span class="emphasis"><em>session-par-requête</em></span> discuté plus haut, toutes les entités chargées en mémoire deviendront des objets détachés durant le temps de réflexion de l'usager. Hibernate vous permet de rattacher ces objets et de persister les modifications y ayant été apportées. Ce pattern est appelé: <span class="emphasis"><em>session-per- request-with-detached-objects</em></span> (littéralement: session- par-requête-avec-objets-détachés). Le versionnage automatique est utilisé afin d'isoler les modifications concurrentes.  </p></li><li><p><span class="emphasis"><em>Session Longues (conversation)</em></span> - Une <code class="literal">Session</code> Hibernate peut être déconnectée de la couche JDBC sous-jacente après que commit() ait été appelé sur une transaction à la base de données et reconnectée lors d'une nouvelle requête-client. Ce pattern s'appelle: <span class="emphasis"><em>session-per-conversation</em></span> (Littéralement: session-par- conversation) et rend superflu le rattachement des objets. Le versionnage automatique est utilisé afin d'isoler les modifications concurrentes.  </p></li></ul></div><p>Les deux patterns <span class="emphasis"><em>session-per-request-with- detached- objects</em></span> (session-par-requête-avec-objets- détachés) et <span class="emphasis"><em>session-per-conversation</em></span> (session-par-conversation) ont chacun leurs avantages et désavantages qui seront exposés dans ce même chapitre, dans la section au sujet du contrôle optimiste de concurrence.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>13.1.3. L'identité des objets</h3></div></div></div><p>Une application peut accéder à la même entité persistante de manière concurrente dans deux <code class="literal">Session</code> s différentes. Toutefois, une instance d'une classe persistante n'est jamais partagée par deux instances distinctes de la classe <code class="literal">Session</code>. Il existe donc deux notions de l'identité d'un objet : </p><div class="variablelist"><dl><dt><span class="term">Identité de database</span></dt><dd><p>
                            <code class="literal">foo.getId().equals( bar.getId() )</code>
                        </p></dd><dt><span class="term">Identité JVM</span></dt><dd><p>
                            <code class="literal">foo==bar</code>
                        </p></dd></dl></div><p>Ainsi, pour des objets attachés à une <code class="literal">Session</code><span class="emphasis"><em>particulière</em></span> (c'est-à-dire dans la portée d'une instance de <code class="literal">Session</code>), ces deux notions d'identité sont équivalentes et l'identité JVM pour l'identité de la base de données sont  garanties par Hibernate. Cependant, alors qu'une application peut accéder de manière concurrente au "même" objet métier (identité persistante) dans deux sessions différentes, les deux instances seront en fait "différentes" (en ce qui a trait à l'identité JVM). Les conflits sont résolus automatiquement par approche optimiste grâce au système de versionnage automatique au moment du flush/sauvegarde.  </p><p>Cette approche permet de reléguer à Hibernate et à la base de données sous-jacente le soin de gérer les problèmes d'accès concurrents. Cette manière de faire assure également une meilleure extensibilité de l'application puisque assurer l'identité JVM dans un thread ne nécessite pas de mécanismes de verrouillage coûteux ou d'autres dispositifs de synchronisation. Une application n'aura jamais besoin de synchroniser des objets d'affaire tant qu'elle peut garantir qu'un seul thread aura accès à une instance de <code class="literal">Session</code> . Dans le cadre d'exécution d'un objet <code class="literal">Session</code>, l'application peut utiliser en toute sécurité <code class="literal">== </code> pour comparer des objets.  </p><p>Une application qui utiliserait <code class="literal">==</code> à l'extérieur du cadre d'exécution d'une <code class="literal">Session</code> pourrait obtenir des résultats inattendus. Par exemple, si vous mettez deux objets dans le même <code class="literal">Set</code> , ceux-ci pourraient avoir la même identité de base de données (c'est-à-dire ils représentent le même enregistrement), mais leur identité JVM pourrait être différente (elle ne peut, par définition, pas être garantie sur deux objets détachés). Le développeur doit donc redéfinir l'implémentation des méthodes <code class="literal">equals()</code> et <code class="literal">hashcode()</code> dans les classes persistantes et y adjoindre sa propre notion d'identité. Il existe toutefois une restriction : il ne faut jamais utiliser uniquement l'identifiant de la base de données dans l'implémentation de l'égalité; il faut utiliser une clé d'affaire, généralement une combinaison de plusieurs attributs uniques, si possible immuables. Les identifiants de base de données vont changer si un objet transitoire (transient) devient persistant. Si une instance transitoire (en général avec des instances dégachées) est contenue dans un <code class="literal">Set</code>, changer le hashcode brisera le contrat du <code class="literal">Set</code> . Les attributs pour les clés d'affaire n'ont pas à être aussi stables que des clés primaires de bases de données. Il suffit simplement qu'elles soient stables tant et aussi longtemps que les objets sont dans le même <code class="literal">Set</code> . Veuillez consulter le site web Hibernate pour des discussions plus pointues à ce sujet. Notez que ce concept n'est pas propre à Hibernate mais bien général à l'implémentation de l'identité et de l'égalité en Java.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>13.1.4. Problèmes communs</h3></div></div></div><p>Bien qu'il puisse y avoir quelques rares exceptions à cette règle, il est recommandé de ne jamais utiliser les anti-modèles <span class="emphasis"><em>session-par- utilisateur-session</em></span> ou <span class="emphasis"><em>session-par-application</em></span> . Notez que certains des problèmes suivants pourraient néanmoins survenir avec des modèles recommandés, assurez-vous de bien comprendre les implications de chacun des modèles avant de prendre une décision concernant votre design : </p><div class="itemizedlist"><ul><li><p>L'objet <code class="literal">Session</code> n'est pas conçu pour être utilisé par de multiples threads. En conséquence, les objets potentiellement multi-thread comme les requêtes HTTP, les EJB Session et Swing Worker, risquent de provoquer des conditions de course dans la <code class="literal">Session</code> si celle-ci est partagée. Si vous gardez votre <code class="literal">Session</code> Hibernate dans la <code class="literal">HttpSession</code> (le sujet sera traité ultérieurement), il serait préférable de synchroniser les accès à la session Http afin d'éviter qu'un usager ne recharge une page assez rapidement pour que deux requêtes exécutant dans des threads concurrents n'utilisent la même <code class="literal">Session</code>. </p></li><li><p>Lorsque Hibernate lance une exception, le rollback de la transaction en cours dans la base de données, doit être effectué et la <code class="literal">Session</code> immédiatement fermée. (Nous approfondirons le sujet plus loin) Si votre <code class="literal">Session</code> est liée à l'application, il faut arrêter l'application. Le rollback de la transaction de base de données ne remettra pas les objets dans leur état du début de la transaction. Ainsi, cela signifie que l'état de la base de données et les objets d'affaires pourraient être désynchronisés d'avec les enregistrements. Généralement, cela ne cause pas de réel problème puisque la plupart des exceptions sont non traitables et de toutes façons, vous devez recommencer le processus après le rollback).  </p></li><li><p>The <code class="literal">Session</code> caches every object that is in a persistent state (watched and checked for dirty state by Hibernate). If you keep it open for a long time or simply load too much data, it will grow endlessly until you get an OutOfMemoryException. One solution is to call <code class="literal">clear()</code> and <code class="literal">evict()</code> to manage the <code class="literal">Session</code> cache, but you should consider a Stored Procedure if you need mass data operations. Some solutions are shown in <a class="xref" href="batch.html" title="Chapitre 15. Traitement par lot">Chapitre 15, <i>Traitement par lot</i></a>. Keeping a <code class="literal">Session</code> open for the duration of a user session also means a higher probability of stale data. </p></li></ul></div></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>13.2. Démarcation des transactions de base de données</h2></div></div></div><p>La démarcation des transactions de base de données (ou système) est toujours nécessaire. Aucune communication avec la base de données ne peut être effectuée à l'extérieur du cadre d'une transaction. (Il semble que ce concept soit mal compris par plusieurs développeurs trop habitués à utiliser le mode auto-commit.) Utilisez toujours la démarcation des des transactions, même pour des opérations en lecture seule. Certains niveaux d'isolation et certaines possibilités offertes par les bases de données permettent de l'éviter, il n'est jamais désavantageux de toujours explicitement indiquer les bornes de transaction. Il est certain qu'une transaction unique de base de données sera plus performante que de nombreuses petites transactions, même pour les opérations simples de lecture.  </p><p>Une application utilisant Hibernate peut s'exécuter dans un environnement léger n'offrant pas la gestion automatique des transactions (application autonome, application web simple ou applications Swing) ou dans un environnement J2EE offrant des services de gestion automatiques des transactions JTA. Dans un environnement simple, Hibernate a généralement la responsabilité de la gestion de son propre pool de connexions à la base de données. Le développeur de l'application doit manuellement délimiter les transactions. En d'autres mots, il appartient au développeur de gérer les appels à <code class="literal">Transaction.begin()</code> , <code class="literal">Transaction.commit()</code> et <code class="literal">Transaction.rollback()</code>. Un environnement transactionnel J2EE (serveur d'application J2EE) doit offrir la gestion des transactions au niveau du conteneur J2EE. Les bornes de transaction peuvent normalement être définies de manière déclarative dans les descripteurs de déploiement d'EJB Session, par exemple. La gestion programmatique des transactions n'y est donc plus nécessaire. </p><p>Cependant, il est souvent préférable d'avoir une couche de persistance portable entre les environnements non gérés de ressources locales et les systèmes qui s'appuient sur JTA mais utilisent BMT à la place de CMT. Dans les deux cas, vous utiliserez la démarcation de transaction programmatique. Hibernate offre donc une API appelée <code class="literal">Transaction</code> qui sert d'enveloppe pour le système de transaction natif de l'environnement de déploiement. Il n'est pas obligatoire d'utiliser cette API, mais il est fortement conseillé de le faire, sauf lors de l'utilisation de CMT Session Bean. </p><p>Il existe quatre étapes distinctes lors de la fermeture d'une <code class="literal">Session</code> : </p><div class="itemizedlist"><ul compact="compact"><li><p>flush de la session </p></li><li><p>commit de la transaction </p></li><li><p>fermeture de la session  </p></li><li><p>gestion des exceptions </p></li></ul></div><p>La notion de "Flushing" a déjà été expliquée, nous abordons maintenant la démarcation des transactions et la gestion des exceptions dans les environnements gérés et non-gérés. </p><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>13.2.1. Environnement non gérés</h3></div></div></div><p>Si la couche de persistance Hibernate s'exécute dans un environnement non géré, les connexions à la base de données seront généralement prises en charge par le mécanisme de pool d'Hibernate qui obtient les connexions. La gestion de la session et de la transaction se fera donc de la manière suivante :  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>You do not have to <code class="literal">flush()</code> the <code class="literal">Session</code> explicitly: the call to <code class="literal">commit()</code> automatically triggers the synchronization depending on the <a class="link" href="objectstate.html#objectstate-flushing" title="11.10. Flush de la session">FlushMode</a> for the session. A call to <code class="literal">close()</code> marks the end of a session. The main implication of <code class="literal">close()</code> is that the JDBC connection will be relinquished by the session. This Java code is portable and runs in both non-managed and JTA environments. </p><p>Une solution plus flexible est la gestion par contexte de la session courante intégrée, fournie par Hibernate que nous avons déjà rencontrée : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Vous ne verrez probablement jamais ces exemples de code dans les applications ; les exceptions fatales (exceptions du système) ne devraient être traitées que dans la couche la plus "haute". En d'autres termes, le code qui exécute les appels à Hibernate (à la couche de persistance) et le code qui gère les <code class="literal">RuntimeException</code> (qui ne peut généralement effectuer qu'un nettoyage et une sortie) sont dans des couches différentes. La gestion du contexte courant par Hibernate peut simplifier notablement ce design, puisqu'il vous suffit d'accéder à la <code class="literal">SessionFactory</code>. La gestion des exceptions est traitée plus loin dans ce chapitre.  </p><p>Notez que vous devriez sélectionner <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code> (le défaut), pour le second exemple <code class="literal">"thread"</code> comme votre <code class="literal">hibernate.current_session_context_class</code>.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>13.2.2. Utilisation de JTA</h3></div></div></div><p>Si votre couche de persistance s'exécute dans un serveur d'applications (par exemple, derrière un EJB Session Bean), toutes les datasources utilisées par Hibernate feront automatiquement partie de transactions JTA globales. Vous pouvez également installer une implémentation autonome JTA et l'utiliser sans l'EJB.Hibernate propose deux stratégies pour réussir l'intégration JTA.  </p><p>Si vous utilisez des transactions gérées par un EJB (bean managed transactions - BMT), Hibernate informera le serveur d'applications du début et de la fin des transactions si vous utilisez l'API <code class="literal">Transaction</code>. Ainsi, le code de gestion des transactions sera identique dans les environnements non gérés.  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Si vous souhaitez utiliser une <code class="literal">Session</code> couplée à la transaction, c'est à dire, utiliser la fonctionnalité <code class="literal">getCurrentSession()</code> pour la propagation facile du contexte, vous devez utiliser l'API JTA <code class="literal">UserTransaction</code> directement : </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>Avec CMT, la démarcation des transactions est faite dans les descripteurs de déploiement des Beans Sessions et non de manière programmatique, par conséquent le code est réduit à :  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre><p>Dans un EJB CMT, le rollback aussi intervient automatiquement, puisqu'une <code class="literal">RuntimeException</code> non traitée et soulevée par une méthode d'un bean session indique au conteneur d'annuler la transaction globale. <span class="emphasis"><em>Ceci veut donc dire que vous n'avez pas à utiliser l'API <code class="literal">Transaction</code> de Hibernate dans CMT ou BMT et vous obtenez la propagation automatique de la session courante liée à la transaction.</em></span> </p><p>Notez que le fichier de configuration Hibernate devrait contenir les valeurs <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> dans un environnement BMT ou <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> dans un environnement CMT là où vous configurez votre fabrique de transaction Hibernate. N'oubliez pas non plus de spécifier le paramètre <code class="literal">org.hibernate.transaction.manager_lookup_class</code> . De plus, assurez vous de fixer votre <code class="literal">hibernate.current_session_context_class</code> soit à <code class="literal">"jta"</code> ou de ne pas le configurer (compatibilité avec les versions précédentes).  </p><p>La méthode <code class="literal">getCurrentSession()</code> a un inconvénient dans les environnements JTA. Il y a une astuce qui est d'utiliser un mode de libération de connexion <code class="literal">after_statement</code> , qui est alors utilisé par défaut. Du à une étrange limitation de la spec JTA, il n'est pas possible à Hibernate de nettoyer automatiquement un <code class="literal">ScrollableResults</code> ouvert ou une instance d'<code class="literal">Iterator</code> retournés <code class="literal">scroll()</code> ou <code class="literal">iterate()</code>. Vous <span class="emphasis"><em>devez</em></span> libérer le curseur base de données sous jacent ou invoquer <code class="literal">Hibernate.close(Iterator)</code> explicitement depuis un bloc <code class="literal">finally</code>. (Bien sur, la plupart des applications peuvent éviter d'utiliser <code class="literal">scroll()</code> ou <code class="literal">iterate()</code> dans un code JTA ou CMT.)  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>13.2.3. Gestion des exceptions</h3></div></div></div><p>Si une <code class="literal">Session</code> lance une exception (incluant les exceptions du type <code class="literal">SQLException</code> ou d'un sous-type), vous devez immédiatement effectuer le rollback de la transaction, appeler <code class="literal">Session.close()</code> et relâcher les références sur l'objet <code class="literal">Session</code> . La <code class="literal">Session</code> contient des méthodes pouvant la mettre dans un état inutilisable. Vous devez considérer qu'<span class="emphasis"><em>aucune</em></span> exception lancée par Hibernate n'est traitable comme recouvrable. Assurez-vous de fermer la session en appelant <code class="literal">close()</code> dans un bloc <code class="literal">finally</code> .  </p><p>L'exception <code class="literal">HibernateException</code>, qui englobe la plupart des exceptions pouvant survenir dans la couche de persistance Hibernate, est une exception non vérifiée (Ceci n'était pas le cas dans des versions antérieures de Hibernate.) Nous pensons que nous ne devrions pas forcer un développeur à gérer une exception qu'il ne peut de toute façon pas traiter dans une couche technique. Dans la plupart des systèmes, les exceptions non vérifiées et les exceptions fatales sont gérées en amont du processus (dans les couches hautes) et un message d'erreur est alors affiché à l'usager (ou un traitement alternatif est invoqué.) Veuillez noter que Hibernate peut également lancer des exceptions non vérifiées d'un autre type que <code class="literal">HibernateException</code>. Celles-ci sont également non traitables et vous devez les traiter comme telles.  </p><p>Hibernate 