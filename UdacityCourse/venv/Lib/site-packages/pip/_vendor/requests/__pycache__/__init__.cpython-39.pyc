and
                    <interfacename>org.hibernate.usertype.CompositeUserType</interfacename> were originally
                    added to isolate user code from internal changes to the <interfacename>org.hibernate.type.Type</interfacename>
                    interfaces.
                </para>
            </note>
            <para>
                The second approach is the use the <interfacename>org.hibernate.usertype.UserType</interfacename>
                interface, which presents a somewhat simplified view of the <interfacename>org.hibernate.type.Type</interfacename>
                interface.  Using a <interfacename>org.hibernate.usertype.UserType</interfacename>, our
                <classname>Money</classname> custom type would look as follows:
            </para>
            <example id="types-custom-ut-ex-definition">
                <title>Defining the custom UserType</title>
                <programlisting role="JAVA"><![CDATA[public class MoneyType implements UserType {
    public int[] sqlTypes() {
        return new int[] {
                BigDecimalType.INSTANCE.sqlType(),
                CurrencyType.INSTANCE.sqlType(),
        };
    }

    public Class getReturnedClass() {
        return Money.class;
    }

    public Object nullSafeGet(ResultSet rs, String[] names, Object owner) throws SQLException {
        assert names.length == 2;
        BigDecimal amount = BigDecimalType.INSTANCE.get( names[0] ); // already handles null check
        Currency currency = CurrencyType.INSTANCE.get( names[1] ); // already handles null check
        return amount == null && currency == null
                ? null
                : new Money( amount, currency );
    }

    public void nullSafeSet(PreparedStatement st, Object value, int index) throws SQLException {
        if ( value == null ) {
            BigDecimalType.INSTANCE.set( st, null, index );
            CurrencyType.INSTANCE.set( st, null, index+1 );
        }
        else {
            final Money money = (Money) value;
            BigDecimalType.INSTANCE.set( st, money.getAmount(), index );
            CurrencyType.INSTANCE.set( st, money.getCurrency(), index+1 );
        }
    }

    ...
}]]></programlisting>
            </example>
            <para>
                There is not much difference between the <interfacename>org.hibernate.type.Type</interfacename> example
                and the <interfacename>org.hibernate.usertype.UserType</interfacename> example, but that is only because
                of the snippets shown.  If you choose the <interfacename>org.hibernate.type.Type</interfacename> approach
                there are quite a few more methods you would need to implement as compared to the
                <interfacename>org.hibernate.usertype.UserType</interfacename>.
            </para>
        </section>

        <section id="types-custom-cut">
            <title>Custom types using <interfacename>org.hibernate.usertype.CompositeUserType</interfacename></title>
            <para>
                The third and final approach is the use the <interfacename>org.hibernate.usertype.CompositeUserType</interfacename>
                interface, which differs from <interfacename>org.hibernate.usertype.UserType</interfacename> in that it
                gives us the ability to provide Hibernate the information to handle the composition within the
                <classname>Money</classname> class (specifically the 2 attributes).  This would give us the capability,
                for example, to reference the <literal>amount</literal> attribute in an HQL query.  Using a
                <interfacename>org.hibernate.usert